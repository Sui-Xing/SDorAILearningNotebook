

# master表达式

## 时间复杂度计算

$ T(N)=a×T(\frac{N}{b})+O(N^d) $

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/202303312215798.png)

## 排序

### 归并排序

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/202303312216470.png)

```java
public class guiBing {

    public static void main(String[] args) {
        int arr[]={5,3,6,2,9};
        process(arr,0,4);
        for(int a:arr){
            System.out.println(a);
        }
    }

    public static void process(int[] arr,int L,int R){
        // 注意终止条件
        if(L==R){
            return;
        }
        int mid = L+((R-L)>>1);
        process(arr,L,mid);
        process(arr,mid+1,R);
        merge(arr,L,R,mid);
    }

    public static void merge(int[] arr,int L ,int R,int M){
        int[] help=new int[R-L+1];
        int pointL=L;
        int pointR=M+1;
        int pointH=0;
        while( pointL<=M && pointR<=R  ){
            // 注意是小于等于
            help[pointH++]=arr[pointL]<=arr[pointR]?arr[pointL++]:arr[pointR++];
        }
        while(pointL<=M){
            help[pointH++]=arr[pointL++];
        }
        while (pointR<=R){
            help[pointH++]=arr[pointR++];
        }
        for(int i=0;i<R-L+1;i++){
            arr[L+i]=help[i];
        }

    }
}

```



$ T(N)=2×T(\frac{N}{2})+O(N) $

归并排序满足master表达式

所以时间复杂度为Nlogn

 **归并排序的扩展**

1. 小和问题

2. 逆序对问题



小和问题：

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子：[1,3,4,2,5] 1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、5、2，所以小和为1+1+3+1+1+3+4+2=16

```java
public class qiuXiaoHe {
    public static void main(String[] args) {
        int arr[]={5,3,6,2,9};
        process(arr,0,4);
        for(int a:arr){
            System.out.println(a);
        }
    }

    public static int process(int[] arr,int L,int R){
        // 注意终止条件
        if(L==R){
            return 0;
        }
        int mid = L+((R-L)>>1);

        return process(arr,L,mid)+process(arr,mid+1,R)+merge(arr,L,R,mid);
    }

    public static int merge(int[] arr,int L ,int R,int M){
        int[] help=new int[R-L+1];
        int pointL=L;
        int pointR=M+1;
        int pointH=0;
        int res=0;
        while( pointL<=M && pointR<=R  ){
            // 关键修改点
            res=arr[pointL]<arr[pointR]?(R-pointR+1)*arr[pointL]:0;


            // 注意是小于等于
            help[pointH++]=arr[pointL]<=arr[pointR]?arr[pointL++]:arr[pointR++];
        }
        while(pointL<=M){
            help[pointH++]=arr[pointL++];
        }
        while (pointR<=R){
            help[pointH++]=arr[pointR++];
        }
        for(int i=0;i<R-L+1;i++){
            arr[L+i]=help[i];
        }
        return res;
    }
}
```





逆序对问题：

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。





### 快速排序

**荷兰国旗问题**

**问题一**

给第一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)



**问题二**

给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)



---

**快速排序**

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403155105.png)



![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/04/20230404194608.png)

1. arr[i]<num，arr[i]和<区域下一个做交换，<指针右移，i++

2. arr[i]==num，i++

3. arr[i]>num，arr[i]和>区域前一个做交换，>区域右阔1，i不变





![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403154810.png)

### 堆排序

#### heap insert

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403160758.png)



#### heapify

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403163047.png)



#### 排序

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403165717.png)

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403172242.png)


