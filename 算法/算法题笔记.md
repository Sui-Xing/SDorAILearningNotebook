# master表达式

## 时间复杂度计算

$ T(N)=a×T(\frac{N}{b})+O(N^d) $

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/202303312215798.png)

## 排序

### 归并排序

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/202303312216470.png)

```java
public class guiBing {

    public static void main(String[] args) {
        int arr[]={5,3,6,2,9};
        process(arr,0,4);
        for(int a:arr){
            System.out.println(a);
        }
    }

    public static void process(int[] arr,int L,int R){
        // 注意终止条件
        if(L==R){
            return;
        }
        int mid = L+((R-L)>>1);
        process(arr,L,mid);
        process(arr,mid+1,R);
        merge(arr,L,R,mid);
    }

    public static void merge(int[] arr,int L ,int R,int M){
        int[] help=new int[R-L+1];
        int pointL=L;
        int pointR=M+1;
        int pointH=0;
        while( pointL<=M && pointR<=R  ){
            // 注意是小于等于
            help[pointH++]=arr[pointL]<=arr[pointR]?arr[pointL++]:arr[pointR++];
        }
        while(pointL<=M){
            help[pointH++]=arr[pointL++];
        }
        while (pointR<=R){
            help[pointH++]=arr[pointR++];
        }
        for(int i=0;i<R-L+1;i++){
            arr[L+i]=help[i];
        }

    }
}
```

$ T(N)=2×T(\frac{N}{2})+O(N) $

归并排序满足master表达式

所以时间复杂度为Nlogn

 **归并排序的扩展**

1. 小和问题

2. 逆序对问题

小和问题：

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例子：[1,3,4,2,5] 1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、5、2，所以小和为1+1+3+1+1+3+4+2=16

```java
public class qiuXiaoHe {
    public static void main(String[] args) {
        int arr[]={5,3,6,2,9};
        process(arr,0,4);
        for(int a:arr){
            System.out.println(a);
        }
    }

    public static int process(int[] arr,int L,int R){
        // 注意终止条件
        if(L==R){
            return 0;
        }
        int mid = L+((R-L)>>1);

        return process(arr,L,mid)+process(arr,mid+1,R)+merge(arr,L,R,mid);
    }

    public static int merge(int[] arr,int L ,int R,int M){
        int[] help=new int[R-L+1];
        int pointL=L;
        int pointR=M+1;
        int pointH=0;
        int res=0;
        while( pointL<=M && pointR<=R  ){
            // 关键修改点
            res=arr[pointL]<arr[pointR]?(R-pointR+1)*arr[pointL]:0;


            // 注意是小于等于
            help[pointH++]=arr[pointL]<=arr[pointR]?arr[pointL++]:arr[pointR++];
        }
        while(pointL<=M){
            help[pointH++]=arr[pointL++];
        }
        while (pointR<=R){
            help[pointH++]=arr[pointR++];
        }
        for(int i=0;i<R-L+1;i++){
            arr[L+i]=help[i];
        }
        return res;
    }
}
```

逆序对问题：

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

### 快速排序

**荷兰国旗问题**

**问题一**

给第一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

**问题二**

给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)

---

**快速排序**

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403155105.png)

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/04/20230404194608.png)

1. arr[i]<num，arr[i]和<区域下一个做交换，<指针右移，i++

2. arr[i]==num，i++

3. arr[i]>num，arr[i]和>区域前一个做交换，>区域右阔1，i不变

```java
public class kuaiPai {
    public static void main(String[] args) {
        int[] arr={5,3,1,7,3,9};
        quickSort(arr,0,arr.length-1);
        for(int i:arr){
            System.out.println(i);
        }
    }

    public static void quickSort(int[] arr,int L,int R){
        if(L>=R)return;
        int numIdx=(int) (Math.random()*(R-L+1));
        swap(arr,L+numIdx,R);
        int[] p = partition(arr,L-1,R+1);
        quickSort(arr,L,p[0]);
        quickSort(arr,p[1],R);

    }

    // 返回左区域的右边界，以及右区域的左边界
    public static int[] partition(int[] arr,int L,int R){
        int num=arr[R-1];
        int point=L+1;
        int pointL=L;
        int pointR=R;
        while(point<pointR){
            if(arr[point]<num){
                swap(arr,++pointL,point++);
            }
            else if(arr[point]==num){
                point++;
            }
            else if(arr[point]>num){
                swap(arr,--pointR,point);
            }
        }
        int[] p={pointL,pointR};
        return p;

    }

    public static void swap(int[] arr,int L,int R){
        int temp=arr[L];
        arr[L]=arr[R];
        arr[R]=temp;
    }
}
```

### 堆排序

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/06/20230406162540.png)

#### heap insert

挨个在数组中添加数字，生成大顶堆

```java
   public static void heapInsert(int[] arr,int index){
        while(arr[index]>arr[(index-1)/2]){
            swap(arr,index,(index-1)/2);
            index=(index-1)/2;
        }
    }
```

#### heapify

```java
public static void heapify(int[] arr ,int heapSize){


        int point=0;
        int larger=0;
        while((point*2+1)<=heapSize){
            larger=point*2+2<=heapSize && arr[point*2+1]<arr[point*2+2]?point*2+2:point*2+1;
            larger=arr[point]>arr[larger]?point:larger;
            if(larger==point){
                break;
            }
            swap(arr,point,larger);
            point=larger;
        }
```

#### 排序

方法一：

```java
public static void heapSort(int[] arr){
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr,i);
        }
        int heapSize=arr.length-1;
        while(heapSize>0){
            swap(arr,0,heapSize--);
            heapify(arr,heapSize);
        }
    }
```

方法二：

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/06/20230406160520.png)

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/03/20230403172242.png)

#### 扩展题目

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/06/20230406163254.png)

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/06/20230406163810.png)

**需要手写堆的场景**：需要对堆的内部进行修改



___



## 比较器

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/08/20230408125331.png)+



![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/08/20230408125422.png)





## 桶排序

![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/08/20230408125224.png)



![](http://fastly.jsdelivr.net/gh/Sui-Xing/Figurebed//img/2023/04/08/20230408125209.png)
